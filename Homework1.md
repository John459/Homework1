John Zavidniak
# Homework 1
1.	The essential difficulties are those problems for which no silver bullet exists. By this, it is meant that “there is no single development, in either technology or in management technique, that by itself promises even one order-of-magnitude improvement in productivity, in reliability, in simplicity”. One example of an essential difficulty is the complexity of software projects. There is no silver bullet which may be used to simplify the complexity of any arbitrary project.
2.	The accidental difficulties are those difficulties which are temporary and able to be solved. That is, as developments are made in the field of software engineering the number of accidental difficulties in existence begins to diminish. One example of an accidental difficulty is dealing with bits, registers, memory management, etc. in programming languages. These difficulties were solved by the introduction of high level programming languages which abstracted those details away.
3.	
   -	Complexity: Complexity is defined as the number of possible states that something may be in. Software has an absolutely enormous number of possible states, and this leads to a large multitude of problems. When dealing with large projects the complexity may make it difficult for team members to share information about their specific roles, and it may also make it very difficult to get high test coverage.

   -	Conformity: Software must conform to pre-existing design decisions and interfaces, no matter how complex or arbitrary they are. As a result, simpler designs are pushed away and this conformity leads to even greater complexity. This may be seen if working on legacy code that follow a specific old and poorly designed api.

   -	Changeability: Due to software not existing in any physical way, it is quite easy for it to be modified at a much higher frequency when compared to most other things. These changes often occur either due to expansions of the software’s functionality or modification of the software in order to allow it to work with new physical devices. It is impossible to avoid these changes, and therefore they are considered to be an essential difficulty.

   -	Invisibility: Software does not exist in the physical world, and is therefore unvisualizable. As a result, one may not notice certain aspects of the software being developed, or may miss out on problems. For example, it may be easy to exclude a code path from unit tests due to the fact that the existence of that code path is non-obvious. If the software was visualizable, then that left out code path may have been physically visible and therefore more difficult to accidentally miss.
4.	A silver bullet is defined to be a single development that by itself promises even one order-of-magnitude improvement in productivity, reliability, and simplicity. According to Brooks this cannot exist due to the existence of the essential difficulties. As defined above, essential difficulties are those problems in software development which cannot generally be solved. As long as these problems exist, it follows that a silver bullet which claims to solve these problems cannot exist.

5.	Recall that a Chemist is one who solves theoretical problems in the field of Chemistry, and a Chemical Engineer is one who applies the theoretical results attained by the Chemist in order to solve real world engineering problems. In that regard, a Computer Scientist is like a Chemist and has the job of solving the theoretical problems in the field of Computer Science. Whereas a Software Engineer is like a Chemical Engineer and has the job of applying the results attained by the Computer Scientist to solve real world software engineering problems.

6.	
   -	Abstractions: An abstraction of some entity is another entity with all extraneous information from the original entity removed. For example, there may be a project which involves the treatment of various types of cars. In order to deal with the thousands of different possibilities, the developer may decide to group the cars together into groups based on similar shared characteristics, and exclude any extraneous characteristics that a car may have if it is not shared with any other cars. In this way, the developer is able to reduce the number of objects being considered, and is therefore able to reason about the given problem more easily. Thus, the power of abstractions come from their ability to simplify complex problems.
   
   -	Conversations: The discussions which should occur between everyone involved with a specific project. Consider a project which involves a customer, a software developer, and a marketer. The developer needs to be having conversations with the customer in order to determine exactly what features the project needs to include, and also to let the customer know approximate timeframes for completing these features. In this way, the customer and developer may agree on which features to include, and which to throw out due to lack of importance, time constraints, or other reasons. Along with that, the developer needs to share what features the project will include to the marketer so that it may be properly advertised, and the customer needs to converse with the marketer in order to come to an agreement on exactly how the project should be marketed. Without these conversations, the final project could be one which does not include the necessary features nor the proper marketing strategy.

   -	Specification: The way in which something should be done. A specification defines the necessary requirements, the design that should be implemented, the code that needs to be written, the testing that needs to be done, and so on. The importance of having specifications comes from the fact that when everything is properly documented it is easier to know how much work needs to be done, understand time constraints, and know if things are progressing as they should be or not. Along with that, specifications give one a roadmap to follow as development continues, ensuring that development is staying on track.

   -	Translation: The process of converting one entity into another entity (e.g. a specification, abstraction, design, problem, etc.). Translations allow developers to take existing work and convert it to their specific use case. For example, there may be software that has been written to one specification that now needs to be used in a project with different specifications. Or there may be software that has been designed to solve one problem, and it now needs to be translated to solve another related problem. Translation allows a developer to take something which has already been created and modify it to fit the new use case.

   -	Iteration: The process of developing software in a step by step manner in order to produce the desired end result. Iteration allows the developer to consider only small parts of a large project at a time, and therefore reduces the level of complexity that one must deal with at a single time. In this way, reasoning about the project and the work which needs to be completed becomes easier, and therefore the developer is able to produce work more easily.
